# 注解反射

## 注解概念

**注解作用：**注解不会直接影响代码逻辑，但可以被用来“标记”某些信息，从而让工具或框架“知道”该怎么处理这段代码。**注解就像“标签”**：你贴在代码的类、方法、字段、参数上，告诉系统或开发者，“这段代码有个特殊的用途”。`不同的注解，有不同的作用，可以添加在不同的位置，有的可以写值，有的不能写值`。

**JDK支持：**注解是JDK1.5新加入的内容。

**注解的产生：**

```java
Java web开发历程：web项目中会存在大量的配置文件，例如xml yml properties文件等；
配置文件阅读性差，编写错误不能立即提示；配置文件会增加代码的复杂程度；
    
JDK开发人员在1.5引入了注解，用于来替代配置文件；
    
早期：Java代码 + 配置文件
现在：Java代码 + 配置文件 + 注解
    
注解的优点：简化开发 提高代码可读性;
思想：约定大于配置;
```



## 常用注解

@override

该注解用于标识一个方法是重写（Override）父类或接口中的方法。它能帮助编译器检查你是否真正重写了父类的方法，防止拼写错误

```java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog barks");
    }
}

```

@FunctionalInterface

用于标注一个接口是“函数式接口”（只能有一个抽象方法），可以被 Lambda 表达式使用。

```java
@FunctionalInterface
interface MyFunction {
    void execute();  // 只能有一个抽象方法
}

// 使用 Lambda 表达式实现该接口
public class Main {
    public static void main(String[] args) {
        MyFunction func = () -> System.out.println("Hello from functional interface!");
        func.execute();
    }
}

```

@SuppressWarnings("unused")

该注解用于告诉编译器忽略特定的警告信息。`"unused"` 表示忽略“未使用的变量”警告

```java
public class Demo {
    // 注解可以加在方法上和变量上
    @SuppressWarnings("unused")
    public void doSomething() {
        String unusedVar = "I won't be used";
        System.out.println("Doing something");
    }
}

```

@Deprecated

标记某个类、方法、字段“不建议使用”，但仍然可以用。提示开发者使用新版本

```java
@Deprecated
public void oldMethod() {
    System.out.println("This method is deprecated");
}

public void newMethod() {
    System.out.println("Use this method instead");
}

```

@SuppressWarnings

抑制编译器的警告信息，比如 “unchecked”, “deprecation”, “unused” 等

```java
@SuppressWarnings("deprecation")
public void callDeprecated() {
    oldMethod(); // 不会有警告了
}

```

## 元注解

**元注解是用于注解“注解”的注解**，也就是说，它们用来描述其他注解的行为和作用范围。

换句话说，如果你要定义一个自己的注解（如 `@MyAnnotation`），那么就需要用元注解来告诉编译器

```java
1、这个注解应该应用到哪里？
2、它应该保留到什么时候？
3、它能否被继承？
4、能否重复使用？
```

### 常见元注解

| 注解名        | 作用简述                                                 |
| ------------- | -------------------------------------------------------- |
| `@Target`     | 指定注解可以应用到哪些程序元素上（类、方法、字段等）     |
| `@Retention`  | 指定注解在生命周期中的保留策略（源码 / 类文件 / 运行时） |
| `@Documented` | 指定注解是否会包含在 Javadoc 中                          |
| `@Inherited`  | 指定注解是否会被子类继承                                 |
| `@Repeatable` | 允许一个注解在同一位置重复使用（Java 8+）                |

### 元注解示例

✅ 1、`@Target`

> 限定注解能用在什么位置上，比如类、方法、字段、参数等，默认不写，代表可以添加到任何位置。

```java
@Target({ElementType.METHOD, ElementType.TYPE}) // 写多个位置
public @interface MyAnnotation {}
```

📌ElementType常用值：

| 枚举值            | 说明           |
| ----------------- | -------------- |
| `TYPE`            | 类、接口、枚举 |
| `FIELD`           | 成员变量       |
| `METHOD`          | 方法           |
| `PARAMETER`       | 参数           |
| `CONSTRUCTOR`     | 构造函数       |
| `LOCAL_VARIABLE`  | 局部变量       |
| `ANNOTATION_TYPE` | 注解类型       |
| `PACKAGE`         | 包             |

:zap: 注意：如果注解中只有一个属性值，并且属性值为value，则可以直接写值；其他的情况都必须写为 `属性值 = 属性值`形式

```java
// @Target Java源代码内容

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    // 注解中只有一个属性值，并且属性值为value
    ElementType[] value();
}
```

```java
@Target(ElementType.TYPE) // 直接写值
public @interface A1 {

}
```

✅ 2、`@Retention`

> 指定注解的**保留策略**，即它在什么时候对程序可见。

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
}
```

📌Retention常用值：

| 枚举值          | 说明                                               |
| --------------- | -------------------------------------------------- |
| `SOURCE`        | 注解只在源码中存在，编译后被丢弃（如 `@Override`） |
| `CLASS`（默认） | 编译到 class 文件中，运行时不可访问                |
| `RUNTIME`       | 编译进 class，运行时可通过反射读取（框架常用）     |

✅ 3. `@Documented`

> 指定注解是否出现在 Javadoc 中。

```java
@Documented
public @interface MyAnnotation {
}

```

默认情况下，自定义注解不会出现在 Javadoc 中，除非加了 `@Documented`。

:white_check_mark: 4、`@Inherited`

> 指定一个注解是否能被子类继承（仅对类有效）。

```java
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Role {
    String value();
}

```

```java
@Role("admin")
class Parent {}

class Child extends Parent {} // Child 也具有 @Role 注解

```

 注意：只能**用于类**（`ElementType.TYPE`），不能用于方法、字段等。

✅ 5 、`@Repeatable`（Java 8+）

> 允许一个注解在同一个位置**重复使用**。

```java
@Repeatable(Hints.class)
@interface Hint {
    String value();
}

@interface Hints {
    Hint[] value();
}
```

```java
@Hint("hint1")
@Hint("hint2")
public class Person {
}
```

✅ 示例：自定义注解结合元注解使用

新建注解步骤：鼠标右键，新建JavaClass，选择Annotation。

```java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LogExecution {
    String value() default "default";
}

```

## 自定义注解

注解也是一种类型。

:white_check_mark: 1、创建元注解

```java

```

:white_check_mark: 2、使用注解

```java

```

## 注解属性



## 应用场景

| 场景                | 示例注解                                      |
| ------------------- | --------------------------------------------- |
| 编译校验            | `@Override`, `@FunctionalInterface`           |
| 开发工具提示        | `@Deprecated`, `@SuppressWarnings`            |
| Java EE/Spring 框架 | `@Component`, `@Autowired`, `@RequestMapping` |
| 测试框架            | `@Test`, `@Before`, `@After`                  |
| ORM 映射            | `@Entity`, `@Table`, `@Column`                |
| 自定义逻辑（反射）  | 自定义注解 + `@Retention(RUNTIME)`            |