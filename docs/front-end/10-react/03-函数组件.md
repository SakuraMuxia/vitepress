# 函数组件

```shell
1. 组件名首字母必须大写. 因为react以此来区分组件元素/标签 和 一般元素/标签
2. 组件内部如果有多个标签,必须使用一个根标签包裹.只能有一个根标签
3. 必须有返回值.返回的内容就是组件呈现的结构, 如果返回值为 null，表示不渲染任何内容
4. 会在组件标签渲染时调用, 但不会产生实例对象（this->undefined）,  不能有状态
```

```jsx
 
function App() {
  // return null
  return <div>App</div>
}

// 函数名就是组件名
ReactDom.render(<App />, document.getElementById('root')) 
```

## 基本介绍

> 函数组件本质就是一个函数

```jsx
语法：
1. 函数名就是组件名，函数名首字母必须大写
2. 函数中必须有return 语句，并且返回react元素
```

```jsx
函数组件的调用: 通过jsx语法调用()
1. 单标签调用： <组件名/>
2. 对标签调用:  <组件名></组件名>
```

```jsx
调用过程:
1. 首先jsx 有首字母大写的标签，会当做组件处理，查找该组件的定义
2. 如果找到了并且发现是函数组件，那么render方法会帮咱们调用函数组件
3. 将函数调用的返回值 [react元素]，替换掉组件调用标签的位置
```

**函数组件的定义及调用**

```jsx
const root = ReactDOM.createRoot(document.querySelector("#root"));
function Header(){
    console.log('Header run');
    console.log('Header this: ', this);// 函数组件中this 指向undefined
    return (
        <div>我是Header组件</div>
    )
}
function Main(){
    return (
        <div>我是Main组件</div>
    )
}
function Footer(){
    return (
        <div>我是Footer组件</div>
    )
}
root.render((
    <>
        <Header></Header>
        <Header/>
        <Main/>
        <Footer/>
    </>
))
```

**自定义render模拟函数组件调用渲染过程**

> 函数组件中的this，指向undefined

```jsx
const root = ReactDOM.createRoot(document.querySelector("#root"));

function Header(){
    return (
        <div>我是Header组件</div>
    )
}

function renderByMy(reactComponent, root){
    console.log('reactComponent: ', reactComponent);// react元素
    console.log('reactComponent.type',reactComponent.type);// Header组件函数
    // 调用Header组件函数
    const vdom = reactComponent.type(); // vdom 是Header组件调用的返回值【react元素】
    console.log('vdom: ', vdom);
    // 创建真实dom
    const realDom = document.createElement(vdom.type);
    // 添加内容
    realDom.innerHTML = vdom.props.children;
    // 将真实dom渲染到根节点
    root.appendChild(realDom);
}

const oRoot = document.querySelector('#root');
renderByMy(<Header/>, oRoot);
```

## props 外部数据

> 组件间通信的借助props传递

父组件向子组件传递数据

```jsx
- 父组件如何传递数据给子组件？
  1. 通过子组件调用标签属性的方式传递
  
- 子组件如何接收父组件传递的数据？
  1. 类子组件通过 this.props属性接收	
  2. 函数子组件通过函数的形参接收【一般会直接在参数位置解构】
```

子组件向父组件传递数据，也是借助props

```jsx
1. 在父组件定义一个方法，方法设置一个或多个形参
2. 将该方法改变this指向，让this指向当前组件的实例对象
3. 将该方法通过标签数据性的方式传递给子组件
4. 在子组件中通过 props接收
   1. 类组件： this.props.方法名
   2. 函数组件: props.方法名
5. 在子组件中调用该方法，并将要传递的数据以实参的方式传递
```

> 注意：
>
> props外部数据是只读的，在子组件中不可以直接修改
>
> props的children属性，可以接收到组件调用对标签中的子元素

### 父向子传值(类-函)

> 函数子组件也可以接收外部数据props，或通过函数组件的形参接收

**函数子组件通过形参接收数据**

父组件：src->App.js

```jsx
import React, { Component } from 'react'
import FunCom from './components/FunCom';
/**
 * 状态数据研究三个方向：
 * 1. 如何定义状态
 * 2. 如何读取状态
 * 3. 如何修改状态
 */
export default class App extends Component {
    state = {
        count:99,
        msg:'atguigu123'
    }
    addCount(num){
        
        this.setState({
            count: this.state.count + num
        })
    }

    changeMsg(){
        this.setState({
            // msg: 'atguigu123123123123123212'
            msg:this.state.msg + '!'
        })
    }

    render() {
        console.log('render run');
        let {count,msg} = this.state;
        return (
            <div>
                <p>count : {this.state.count}-{count}</p>
                <p>msg: {this.state.msg}-{msg}</p>
                <p><button onClick={()=>this.addCount(3)}>count++ </button></p>
                <p><button onClick={()=>this.changeMsg()}>msg + !</button></p>
                <hr/>
                {/* 父组件通过子组件标签属性传递数据给子组件 */}
                {/* <ClassCom num={count} xiaoxi={msg} school='尚硅谷'/> */}
                <ClassCom count={count} msg={msg} school='尚硅谷'/>
                <FunCom/>
            </div>
        )
    }
}
```

子组件：src->FunCom.js：通过 形参接收

```jsx
import React from 'react'
// 直接在参数位置解构props对象中的数据
export default function FunCom({count, msg ,school}) {
    console.log('FunCom run');
    
    return (
        <div>
            <h3>FunCom</h3>
            <p>props count: {count}</p>
            <p>props msg: {msg}</p>
            <p>props school: {school}</p>
        </div>
    )
}

// export default function FunCom(props) {
//     console.log('FunCom run');
//     console.log('props: ', props);
//     let {count, msg ,school} = props
//     return (
//         <div>
//             <h3>FunCom</h3>
//             <p>props count: {props.count}-{count}</p>
//             <p>props msg: {props.msg}-{msg}</p>
//             <p>props school: {props.school}-{school}</p>
//         </div>
//     )
// }


```

### 子向父传值(函-类)

```jsx
1. 父组件定义方法
2. 通过 子组件标签属性将方法传递给子组件 [注意要改变该方法的this指向,this的指向为父组件实例]
3. 子组件通过props接收
4. 子组件调用方法并将数据以实参的形式传递
```

父组件：src->App.js

```js
import React, { Component } from 'react'
import FunCom from './components/FunCom';
/**
 * 状态数据研究三个方向：
 * 1. 如何定义状态
 * 2. 如何读取状态
 * 3. 如何修改状态
 */
export default class App extends Component {
    state = {
        count:99,
        msg:'atguigu123'
    }
    addCount(num){
        
        this.setState({
            count: this.state.count + num
        })
    }

    changeMsg(){
        this.setState({
            // msg: 'atguigu123123123123123212'
            msg:this.state.msg + '!'
        })
    }

    // 1. 定义一个方法
    decCount(num){
        this.setState({
            count:this.state.count - num
        })
    }

    render() {
        console.log('render run');
        let {count,msg} = this.state;
        return (
            <div>
                <p>count : {this.state.count}-{count}</p>
                <p>msg: {this.state.msg}-{msg}</p>
                <p><button onClick={()=>this.addCount(3)}>count++ </button></p>
                <p><button onClick={()=>this.changeMsg()}>msg + !</button></p>
                <hr/>
                {/* 将decCount this指向改变为当前实例对象后传递给子组件 */}
                <ClassCom count={count} msg={msg} school='尚硅谷' decCount={this.decCount.bind(this)}/>
                {/* 函数子组件也是通过属性传递数据 */}
                <FunCom  count={count} msg={msg} school='尚硅谷' decCount={this.decCount.bind(this)}/>
            </div>
        )
    }
}
```

子组件：src->FunCom.js

```jsx
import React from 'react'
// 直接在参数位置解构props对象中的数据 接收方法 decCount
export default function FunCom({count, msg ,school,decCount}) {
    console.log('FunCom run');
    return (
        <div>
            <h3>FunCom</h3>
            <p>props count: {count}</p>
            <p>props msg: {msg}</p>
            <p>props school: {school}</p>
            <p><button onClick={()=>{
                // 调用方法，并传递参数
                decCount(7);
            }}>子传父</button></p>
        </div>
    )
}
```

### 限定props类型

使用prop-types 包，对传入的外部数据进行类型、必填、默认值的限定

```jsx
import PropTypes from 'prop-types'
```

函数组件通过把函数当作一个对象，然后添加属性的方式实现

```jsx
TestFun.propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
}

TestFun.defaultProps = {
    age: 10000
}
```

**使用案例**

父组件：src->App.jsx

```js

```

子组件：src->components->Child.jsx

```jsx

```

