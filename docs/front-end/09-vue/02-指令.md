# Vue中的指令(标签属性)

就是对标签属性的拓展

极简插件：https://chrome.zzzmh.cn/#/index

> 指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。指令 attribute 的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。
>
> 指令即是特殊的属性（以v-为前缀）
>
> 指令分为内置指令与自定义指令。
>
> 注意：组件是对标签的扩展，指令是对属性的扩展。

## v-html 文本

更新元素的 [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)

- **期望的绑定值类型：**`string`

v-html属性的特点：

```javascript
 1- 值是一个字符串
 2- 该字符串会作为Vue实例的属性名，将对应的属性值在指令所在的标签中进行输出。
 3- 会覆盖原有数据。
 4- 属性名可以使用双引号，单引号
 5- 属性名也可以省略双引号，单引号
 6- 如果使用的是反引号会将包裹的值在标签中直接输出
 7- 无法与template结合使用。
```

```html
<body>
	<div id="root">
		<h3>v-text</h3>
		<p v-text="userName">{{str}}</p>
		<p v-text='userName'>{{str}}</p>
		<p v-text=userName>{{str}}</p>
		<p v-text=`userName`>{{str}}</p>
	</div>
</body>
<script>
	new Vue({
		el:"#root",
		data:{
			str:"我是一个字符串",
			userName:"zhangsan"
		}
	})
</script>
```

## v-text 文本

更新元素的文本内容。将覆盖元素中所有现有的内容

- **期望的绑定值类型：**`string`

```javascript
<span v-text="msg"></span>
<!-- 等同于 -->
<span>{{msg}}</span>
```

 `区别`：v-text不支持HTML标签而v-html支持。



## v-if 条件

基于表达式值的真假性，来条件性地渲染元素或者模板片段。

- **期望的绑定值类型：**`any`

- 当 `v-if` 元素被触发，元素及其所包含的指令/组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。

  可用于 `<template>` 表示仅包含文本或多个元素的条件块。

  当条件改变时会触发过渡效果。

  当同时使用时，`v-if` 比 `v-for` 优先级更高。我们并不推荐在一元素上同时使用这两个指令

```javascript
v-if以及v-else-if的值是一个布尔值，如果成立则渲染指令所在的元素，不成立则不渲染

v-else-if需要与v-if结合使用

v-else需要与v-if或v-else结合使用

v-if,v-else-if,v-else指令所在的元素之间不要出现其它元素

v-if = "表达式", 表达式中的变量使用的是实例中的属性或方法
```

```html
<div id="root">
    <p>{{isShow}}</p>
    <p>{{isShow && "你好&&"}}</p>
    <p>{{isShow || "你好||"}}</p>
    <!-- 三元表达式	-->
    <p>{{sex===1?"男":"女"}}</p>
    <p>{{fn()}}</p>
    <!--多条件1-->
    <p>{{getAgeStr()}}</p>
    <!--多条件2-使用指令-->
    <p v-if="age>80">老年</p>
    <p v-else-if="age>40">中年</p>
    <p v-else-if="age>28">壮年</p>
    <p v-else-if="age>18">青年</p>
    <p v-else-if="age>12">少年</p>
    <p v-else-if="age>6">儿童</p>
    <p v-else>婴儿</p>
    
    <hr/>
    <template v-if="isLogin">您好，欢迎您的到来！</template>
    <template v-else>
        <input type="text" placeholder="请输入管理员账号">
        <input type="text" placeholder="请输入管理员密码">
    </template> 
</div>
```

```javascript
new Vue({
    el:"#root",
    data:{
        isShow:true,
        sex:1,
        age:100,
        isLogin:true
    },
    methods:{
        fn(){
            return this.sex===1?"男":"女"
        },
        getAgeStr(){
            if(this.age>80) return "老年";
            if(this.age>40) return "中年"
            if(this.age>28) return "壮年"
            if(this.age>18) return "青年"
            if(this.age>12) return "少年"
            if(this.age>6) return "儿童"
            return "婴儿"
        }
    }
})
```

## v-show 显示

基于表达式值的真假性，来改变元素的可见性。

- **期望的绑定值类型：**`any`

- **详细信息**

  `v-show` 通过设置内联样式的 `display` CSS 属性来工作，当元素可见时将使用初始 `display` 值。当条件改变时，也会触发过渡效果。

  不同之处在于 `v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的 CSS 属性。

  `v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。

```javascript
v-if与v-show的值都是布尔值。
v-if为true表示渲染元素，false表示不渲染元素
v-show为true表示显示元素，false表示隐藏元素（通过display:none）

<div v-show = "表达式"></div>

空字符串，0，undefined,null作为判断条件相当于false
非空字符串，1作为判断条件相当于true
```

**示例代码**

```html
<div id="root">
	<p v-show="'isShow'">3</p>
	<p v-show="''">4</p>
	<p v-show="1">5</p>
	<p v-show="0">6</p>
	<p v-show="true">7</p>
	<p v-show="false">8</p>
	<p v-show="null">9</p>
	<p v-show="undefined">10</p>
</div>

<script>
	new Vue({
		el:"#root",
		data:{
			// isShow:true
		}
	})
</script>

```

## v-if VS v-show

`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。

`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。

相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。

总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。

## v-bind 属性

动态的绑定一个或多个 attribute，也可以是组件的 prop

- **缩写：**

  - `:` 或者 `.` (当使用 `.prop` 修饰符)
  - 值可以省略 (当 attribute 和绑定的值同名时) 3.4+

- **期望绑定值：**`any (带参数) | Object (不带参数)`

- **参数：**`attrOrProp (可选的)`

- **修饰符**

  - `.camel` - 将短横线命名的 attribute 转变为驼峰式命名。
  - `.prop` - 强制绑定为 DOM property。3.2+
  - `.attr` - 强制绑定为 DOM attribute。3.2+

- **用途**

  当用于绑定 `class` 或 `style` attribute，`v-bind` 支持额外的值类型如数组或对象。详见下方的指南链接。

  在处理绑定时，Vue 默认会利用 `in` 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 `.prop` 和 `.attr` 修饰符来强制绑定方式。有时这是必要的，特别是在和[自定义元素](https://cn.vuejs.org/guide/extras/web-components.html#passing-dom-properties)打交道时。

  当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。

  当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。

**示例代码**

```html
<!-- 绑定 attribute -->
<img v-bind:src="imageSrc" />

<!-- 动态 attribute 名 -->
<button v-bind:[key]="value"></button>

<!-- 缩写 -->
<img :src="imageSrc" />

<!-- 动态 attribute 名的缩写 -->
<button :[key]="value"></button>

<!-- 内联字符串拼接 -->
<img :src="'/path/to/images/' + fileName" />

<!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src="src" -->
<img :src />

```

**style绑定**

```html
    <div id="root">
        <!-- 未使用style指令 默认 -->
        <p style="background:yellow;color:red;">1</p>
        <!-- 使用style指令  绑定值是一个字符串-->
        <p :style="'background:yellow;color:red;'">2</p>
        <!-- 使用style指令  绑定值是一个字符串-->
        <p :style='"background:yellow;color:red;"'>3</p>
        <!-- 使用style指令  绑定值是一个字符串-->
        <p :style ="one">4</p>

        <!-- 使用style指令  绑定值是一个对象-->
        <p :style="{background:'green',color:'pink'}">5</p>
        <p :style="two">6</p>
        <!-- 使用style指令  绑定值是一个数组-->
        <p :style="[{background:'yellow'},{color:'red'}]">7</p>
        <p :style="[bg,cl]">8</p>
        <p :class="{active:activeIndex===index}">8</p>
    </div>

    <script>
        new Vue({
            el:"#root",
            data:{
                one:"background:yellow;color:red;",
                two:{background:'green',color:'pink'},
                bg:{
                    background:"yellow"
                },
                cl:{
                    color:"red"
                }
            }
        })      
    </script>
```

**class绑定**

绑定值为一个字符串

```html
<style>
    .bg{
        background:yellow;
    }
    .cl{
        color:red;
    }
</style>


<div id="root">
    <!-- 绑定值为一个字符串	-->
    <p class="bg">1</p>
    <p class="cl">2</p>
    <p class="bg cl">3</p>
    <p :class="'bg cl'">4</p>
    <p :class="one">5</p>
    <!-- 绑定值为一个对象：常用	-->
    <!-- class绑定的值可以是对象，对象的属性名即是样式类的名字，值是布尔。如果为true类生效，否则无效	-->
    <p :class="{bg:false,cl:true}">6</p>
    <!-- 绑定值为一个数组	-->
    <p :class="['bg','cl']">7</p>
</div>

<script>
	new Vue({
		el:"#root",
		data:{
			one:'bg cl'
		}
	})
</script>
```

## v-on 事件

给元素绑定事件监听器。

- **缩写：**`@`

- **期望的绑定值类型：**`Function | Inline Statement | Object (不带参数)`

- **参数：**`event` (使用对象语法则为可选项)

- **修饰符**

  - `.stop` - 调用 `event.stopPropagation()`。
  - `.prevent` - 调用 `event.preventDefault()`。
  - `.capture` - 在捕获模式添加事件监听器。
  - `.self` - 只有事件从元素本身发出才触发处理函数。
  - `.{keyAlias}` - 只在某些按键下触发处理函数。
  - `.once` - 最多触发一次处理函数。
  - `.left` - 只在鼠标左键事件触发处理函数。
  - `.right` - 只在鼠标右键事件触发处理函数。
  - `.middle` - 只在鼠标中键事件触发处理函数。
  - `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。


```javascript
语句：如果操作语句比较简单，建议直接写语句
函数：如果操作比较复杂或要在多个不同的地方调用且不需要传递参数使用函数
内联声明：如果操作比较复杂或要在多个不同的地方调用且需要传递参数使用调用函数 
如果要传递事件对象可以通过$event全局对象
v-on可以简写：@
    
事件类型由参数来指定。表达式可以是一个方法名，一个内联声明，如果有修饰符则可省略。
当用于普通元素，只监听原生 DOM 事件。当用于自定义元素组件，则监听子组件触发的自定义事件。
当监听原生 DOM 事件时，方法接收原生事件作为唯一参数。如果使用内联声明，声明可以访问一个特殊的 $event 变量：v-on:click="handle('ok', $event)"。
v-on 还支持绑定不带参数的事件/监听器对的对象。请注意，当使用对象语法时，不支持任何修饰符。
```

**示例代码**

```html
<div id="root">
	<h3>{{num}}</h3>
	<!-- 1-语句	-->
	<button v-on:click="num++">加1</button>
    
	<!-- 2-函数:当点击按钮会调用Vue实例中的函数changeNum	-->
	<button v-on:click="changeNum">加2</button>
    
	<!-- 3-调用函数:函数名后加括号不会被立即调用	-->
	<button v-on:click="changeNum2(3,$event)">加3</button>
	
	<!-- 1-语句	-->
	<button @click="num++">加1</button>
	<!-- 2-函数:当点击按钮会调用Vue实例中的函数changeNum	-->
	<button @click="changeNum">加2</button>
	<!-- 3-调用函数:函数名后加括号不会被立即调用	-->
    <!-- 回调函数中默认接收事件对象$event function($event) -->
	<button @click="changeNum2(3,$event)">加3</button>
</div>

<script>
	
	new Vue({
		el:"#root",
		data:{
			num:0
		},
		methods:{
			changeNum(e){
				this.num+=2;
				// console.log("changeNum",this)
				// console.log(e.target.innerText)
			},
			changeNum2(num,e){
				this.num+=num;
				// console.log("changeNum2",num)
				console.log(e.target.innerText)
			}
		}
	})
</script>
```

```javascript
<!-- 方法处理函数 -->
<button v-on:click="doThis"></button>

<!-- 动态事件 -->
<button v-on:[event]="doThis"></button>

<!-- 内联声明 -->
<button v-on:click="doThat('hello', $event)"></button>
```

**注意事项**

**修饰符**

- `.stop` - 调用 `event.stopPropagation()`。
- `.prevent` - 调用 `event.preventDefault()`。
- `.capture` - 在捕获模式添加事件监听器。
- `.self` - 只有事件从元素本身发出才触发处理函数。
- `.{keyAlias}` - 只在某些按键下触发处理函数。
- `.once` - 最多触发一次处理函数。
- `.left` - 只在鼠标左键事件触发处理函数。
- `.right` - 只在鼠标右键事件触发处理函数。
- `.middle` - 只在鼠标中键事件触发处理函数。
- `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。

示例代码

```javascript
<!-- 停止传播 -->
<button @click.stop="doThis"></button>

<!-- 阻止默认事件 -->
<button @click.prevent="doThis"></button>

<!-- 不带表达式地阻止默认事件 -->
<form @submit.prevent></form>

<!-- 链式调用修饰符 -->
<button @click.stop.prevent="doThis"></button>

<!-- 按键用于 keyAlias 修饰符-->
<input @keyup.enter="onEnter" />

<!-- 点击事件将最多触发一次 -->
<button v-on:click.once="doThis"></button>

<!-- 对象语法 -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
```

监听子组件的自定义事件 (当子组件的“my-event”事件被触发，处理函数将被调用)：

```javascript
<MyComponent @my-event="handleThis" />

<!-- 内联声明 -->
<MyComponent @my-event="handleThis(123, $event)" />
```

## v-model双向绑定

在表单输入元素或组件上创建双向绑定。

- **期望的绑定值类型**：根据表单输入元素或组件输出的值而变化
- **仅限：**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - components

* **修饰符**
  * [`.lazy`](https://cn.vuejs.org/guide/essentials/forms.html#lazy) - 监听 `change` 事件而不是 `input`
  * [`.number`](https://cn.vuejs.org/guide/essentials/forms.html#number) - 将输入的合法字符串转为数字
  * [`.trim`](https://cn.vuejs.org/guide/essentials/forms.html#trim) - 移除输入内容两端空格

**示例**

```html
<div id="root">
	<!-- 单向绑定：视图不会更新数据，但数据发生改变视图会改变	-->
	<input v-bind:value="str" type="text">
	<input :value="str" type="text">
	
	<!-- 双向绑定：视图发生改变数据会变，数据改变视图也会改变	-->
	<input @input="changeStr" :value="str" type="text">
	<input @input="str=$event.target.value" :value="str" type="text">
	<input @input="changeStr2($event)" :value="str" type="text">
	
	<!-- 可以通过v-model指令实现双向绑定	-->
    <!-- 这里的this可以省略 -->
	<input v-model="str" type="text">
	<!-- 注意：v-model只可以与表单元素结合使用-->
   <div v-model="str"></div>
   <h3>{{str}}</h3>
</div>

<script>
	new Vue({
		el:"#root",
		data:{
			str:"大家好！我叫刘德华！"
		},
		methods:{
			changeStr(e){
                // 把实例的事件对象值赋值给实例的str属性
				this.str = e.target.value;
				// console.log(e.target.value)
			},
			changeStr2(e){
				this.str = e.target.value;
			}
		}
	})
</script>
```

**修饰符**

* [`.lazy`](https://cn.vuejs.org/guide/essentials/forms.html#lazy) - 监听 `change` 事件而不是 `input`
* [`.number`](https://cn.vuejs.org/guide/essentials/forms.html#number) - 将输入的合法字符串转为数字
* [`.trim`](https://cn.vuejs.org/guide/essentials/forms.html#trim) - 移除输入内容两端空格

```html
<div id="root">
	<!-- 修饰符trim:去除左右空格	-->
<input v-model.trim="str" type="text">
<h3>青龙{{str}}白虎</h3>

<!-- 修饰符number:类型保持为number	-->
<input type="text" v-model.number="a">+<input type="text" v-model.number="b"> <button @click="sum=a+b">=</button>
<input v-model="sum" type="text">

<!-- 修饰符lazy:当失去焦点之后数据才会进行改变。-->
	<input v-model.lazy="str" type="text">
	<h3>{{str}}</h3>
	<h3>{{str}}</h3>
	<h3>{{str}}</h3>
	<h3>{{str}}</h3>
	<h3>{{str}}</h3>
	<h3>{{str}}</h3>
</div>

<script>
	new Vue({
		el:"#root",
		data:{
			str:"蔡徐坤",
			a:1,
			b:2,
			sum:3
		}
	})
</script>
```

## v-for 遍历

基于原始数据多次渲染元素或模板块。

- **期望的绑定值类型：**`Array | Object | number | string | Iterable`

- **详细信息**

  - 指令值必须使用特殊语法 `alias in expression` 为正在迭代的元素提供一个别名：

  - ```javascript
    <div v-for="item in items">
      {{ item.text }}
    </div>
    ```

  - 或者，你也可以为索引指定别名 (如果用在对象，则是键值)：

  - ```javascript
    <div v-for="(item, index) in items"></div>
    <div v-for="(value, key) in object"></div>
    <div v-for="(value, name, index) in object"></div>
    ```

  - `v-for` 的默认方式是尝试就地更新元素而不移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：

  - ```javascript
    <div v-for="item in items" :key="item.id">
      {{ item.text }}
    </div>
    ```

    

**示例**

```html
	<!-- 1- 数组-->
<div v-for="item in arr">{{item}}</div>
<div v-for="(value,index) in arr">{{index}}：{{value}}</div>
	
	<!-- 2- 对象-->
<div v-for="item in obj">{{item}}</div>
<div v-for="(value,key) in obj">{{key}}:{{value}}</div>
	
	
	<!-- 3- 数字-->
<div v-for="item in num">{{item}}</div>
<div v-for="(n,i) in num">{{i}}:{{n}}</div>
	<!-- 4- 字符串-->
<div v-for="item in str">{{item}}</div>
<div v-for="(s,i) in str">{{i}}:{{s}}</div>


	new Vue({
		el:"#root",
		data:{
			arr:["zhangsan","wangwu","zhaoliu","yanqi","shenba","qianjiu"],
			obj:{
				userName:"zhangsan",
				age:12
			},
			num:10,// [1,2,3,4,5,6,7,8,9,10]
			str:"我爱你中国，我亲爱的母亲，我为你流泪也为你自豪！"
		}
	})
</script>
```

## key 替换

 复用已有元素

- Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染
- 要想每次都重新渲染，只需添加一个具有唯一值的 key 属性

```javascript
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。因为在遍历，需要用 v-bind 来绑定动态值
建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
```

`key` 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。

- **预期**：`number | string | symbol`

- **详细信息**

  在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。

  同一个父元素下的子元素必须具有**唯一的 key**。重复的 key 将会导致渲染异常。

  最常见的用例是与 `v-for` 结合：

  ```javascript
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  也可以用于强制替换一个元素/组件而不是复用它。当你想这么做时它可能会很有用：

  - 在适当的时候触发组件的生命周期钩子
  - 触发过渡

  举例来说：

  ```javascript
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  
  当 text 变化时，<span> 总是会被替换而不是更新，因此 transition 将会被触发。
  ```

  

```html
<!-- 使用ID-->
<div :key="item.id" v-for="item in arr">
    <h3>《{{item.bookName}}》</h3>
    <p>作者：{{item.author}}</p>
    <hr/>
</div>
	
<!-- 使用下标 -->
	<div :key="index" v-for="(item,index) in arr">
		<h3>《{{item.bookName}}》</h3>
		<p>作者：{{item.author}}</p>
		<hr/>
	</div>


<script>
	new Vue({
		el:"#root",
		data:{
			arr:[
				{
					id:1,
					bookName:"天龙八部",
					author:"金庸"
				},{
					id:2,
					bookName: "一念永恒",
					author:"耳根"
				}
			]
		}
	})
</script>
```







