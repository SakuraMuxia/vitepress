# 组件通讯Vue2

## Props

### 使用案例

**vue2父向子传值**

1. src->App.vue

```vue
<template>
<div>
    <h3>vue2->父向子传递参数通过属性进行参数的传递</h3>
    <h3>父组件</h3>
    <p>userName:{{userName}}</p>
    <p>age:{{age}}</p>
    <hr/>
    <Child :userName="userName" :age="age" hobby="1"/>
    <hr/>
    <!--  上面使用子组件的语法糖，效果相同  -->
    <Child v-bind="{userName,age,hobby:'1'}" />
</div>
</template>

<script>
import Child from "@/components/Child";
export default {
    name: "App",
    components: {Child},
    data(){
        return {
            userName:"zhangsan",
            age:10
        }
    }
}
</script>

<style scoped>

</style>
```

2. src->components->Child.vue

```vue
<template>
    <div>
        <h3>子组件Child</h3>
        <p>props->userName->{{userName}}</p>
        <p>props->age->{{age}}</p>
        <p>props->hobby->{{hobby}}</p>
        <p>props->sex->{{sex}}</p>
        <button @click="fn">点我</button>
    </div>
</template>

<script>
export default {
    name: "Child",
    // 1- 数组，数组内的元素是字符串，字符串即是属性的名字
    props:["userName","age"],
    // 2- 对象：对象的属性即是接收的属性。可以对类型进行限制
    props:{
         userName:String,
         age:Number
    },
    // 3- 对象
    props:{
        userName:{
            type:String
        },
        age:{
            type:Number
        },
        hobby:{
            type:String,
            required:true
        },
        sex:{
            type:String,
            default:"男"
        }
    },
    methods:{
        fn(){
            // 可以通过this获取属性，且不允许修改
            console.log(this.userName,this.age,this.hobby,this.sex);
            this.userName= 1;
        }
    }
}
</script>

<style scoped>

</style>
```

## vm.$attrs

```js
类型：{ [key: string]: string }	只读
	包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。
	当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件
```

## vm.$listeners

```js

```

## vm.$emit

在当前组件触发一个自定义事件。任何额外的参数都会传递给事件监听器的回调函数

```js
interface ComponentPublicInstance {
  	$emit(event: string, ...args: any[]): void
}
```

**示例**

```js
export default {
  created() {
    // 仅触发事件
    this.$emit('foo')
    // 带有额外的参数
    this.$emit('bar', 1, 2, 3)
  }
}
```

**更改父组件中的数据的方式：**

```js
方式1：通过父组件向子组件传递一个函数，然后子组件调用这个函数达到子组件改变父组件数据的目的
方式2：通过自定义事件传值并修改
```

### 使用案例

**vue2通过自定义事件更改数据**

1. src->App.vue

```vue
<template>
<div>
    <h3>vue2->自定义事件</h3>
    <h3>父组件</h3>
    <!-- 添加自定义事件到子组件上 changeCount -->
    <Child @changeCount="changeCount" :count="count" :changeCount="changeCount"/>
</div>
</template>

<script>
import Child from "@/components/Child";
export default {
    name: "App",
    components: {Child},
    data(){
        return {
            count:100
        }
    },
    methods:{
        changeCount(count){
            this.count+=count;
        }
    }
}
</script>
```

2. src->components->Child.vue

```vue
<template>
    <div>
        <h3>子组件Child</h3>
        <p>count:{{count}}</p>
        
        <!--更改父组件中的数据的方式-->
        <!--方式1：子组件接收父组件传递过来的函数。当点击按钮时调用。 -->
        <button @click="changeCount(3)">调用函数</button>
        <!--方式2：子组件通过自定义事件 监听自定义事件-->
        <button @click="$emit('changeCount',5)">调用自定义事件</button>
        <button @click="fn">调用自定义事件2</button>
    </div>
</template>

<script>
export default {
    name: "Child",

    props:["count","changeCount"],
    methods:{
        fn(){
            this.$emit("changeCount",6)
        }
    },
    mounted(){
        console.log(this)
    }
}
</script>

<style scoped>

</style>
```

## Vue.prototype

通过在Vue实例的原型连上增加一个属性 Vue.prototype.$bus  实现事件总线

### 事件总线作用

```js
通过使用在Vue原型上设置一个属性(.$bus)，把父组件上设置的事件(this.$on("事件名"))和子组件上监听的事件(this.$emit("事件名"))串联起来(父组件和子组件的this不是同一个对象)。

通过使用 Vue.prototype.$bus = new Vue()

父组件和子组件在调用 this.$bus 指向的是同一个Vue实例，这就解决了this指向不同对象的问题

事件总线的使用：父组件上设置的事件(this.$bus.$on("事件名"))和子组件上监听的事件(this.$bus.$emit("事件名")),就可以实现父子之间传值。
```

### 使用案例

```vue
<div id="app">
    <button @click="fn">FatherBtn</button>
	<hanser ></hanser>
</div>
```

```js
<script type="module">
    // 在Vue的原型上设置一个全局属性 .$bus
    Vue.prototype.$bus = new Vue();
    Vue.component("hanser",{
        data(){
            return{
                num:1
            }
        },
        template:(`
            <button @click="Hanser">hanserBtn</button>
        `),  
        methods:{
            Hanser(){
                // VueComponent的实例;$bus属性在 VueComponent.__proto__.prototype原型上
                console.log('子组件中的this',this); 
                // 子组件设置触发事件 Aqua，并传值
                this.$bus.$emit("Aqua","mooooooooo~");
            },
        },      
    })
    new Vue({
        el:'#app',
        data:{
            age:12
        },
        methods:{
            fn(){
                // 父组件设置触发事件 Aqua，并传值
                this.$bus.$emit('Aqua',"neeeeeeeee~");
            },
        },
        mounted(){
            // Vue的实例;$bus属性在 Vue.prototype上
            console.log("父组件中的this",this); 
            this.$bus.$on('Aqua',function(str){
                console.log('Aqua',str)
            })
        }
    })
    
</script>
```



# 组件通讯Vue3

## defineProps()

> 为了在声明 props 和 emits 选项时获得完整的类型推导支持，我们可以使用 defineProps 和 defineEmits API，它们将自动地在 script setup 标签中可用
>
> 在vue3中相当于vue2中的Props的作用

```js
<script setup>
const props = defineProps({
  foo: String
})

const emit = defineEmits(['change', 'delete'])
// setup 代码
</script>
```

props 和 emit 也可以通过给 defineProps 和 defineEmits 传递纯类型参数的方式来声明（TS写法）

```tsx
const props = defineProps<{
  foo: string
  bar?: number
}>()

const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()

// 另一种更简洁的语法
const emit = defineEmits<{
  change: [id: number] // 具名元组语法
  update: [value: string]
}>()
```

### 特点

> 1. 不需要引入，可以直接使用。已经经过setup处理过了
>
> 2. 指定接收的属性，指定的属性可以在模板中直接使用。
>
> 3. 在script标签中不能用(this.属性值)获取传递过来的参数。需要通过defineProps的返回值获取。

### 使用案例

**Vue3父向子传值**

1. src->App.vue

```vue
<template>
    <h3>Vue3父向子通过属性进行参数的传递</h3>
    <h3>父组件App</h3>
    <p>userName:{{userName}}</p>
    <p>age:{{age}}</p>
    <hr/>
    <Child :userName="userName" :age="age" hobby="学习"/>
    <hr/>
    <Child v-bind="{userName,age,hobby:'学习'}"/>
</template>

<script lang="ts" setup>
import Child from "@/components/Child.vue";
import {ref} from "vue";
const userName = ref("vue3");
const age = ref(12);
</script>

<style scoped>
</style>
```

2. src->components->Child.vue 接收参数需要使用defineProps

```vue
<template>
    <h3>子组件Child</h3>
	<!--模版中可以直接使用defineProps传来的参数-->
    <p>userName:{{ userName }}</p>
    <p>age:{{ age }}</p>
    <p>hobby:{{ hobby }}</p>
    <p>sex:{{ sex }}</p>
    <button @click="fn">点我</button>
</template>

<script lang="ts" setup>
// defineProps有两个特点：
// 1- 不需要引入，可以直接使用,已经经过setup处理过了
// 2- 指定接收的属性，指定的属性可以在模板中直接使用。
//    在script标签中不能用(this.属性值)获取传递过来的参数。需要通过defineProps的返回值获取。

// 1- 数组的形式，数组的元素是字符串，字符串是属性名
defineProps(["userName", "age"]);
// 2- 对象
defineProps({
     userName:String,
     age:Number
})
// 3- 对象，对象的属性值还是对象
const props = defineProps({
    userName:{
        type:String
    },
    age:{
        type:Number
    },
    hobby:{
        type:String,
        required:true
    },
    sex:{
        type:String,
        default:"男"
    }
});
// 通过defineProps的返回值props使用传来的参数
const fn = function(){
    console.log(props); // 一个Proxy类型的对象，target属性中存在着传过来的数据。
    console.log(props.userName);
    console.log(props.age);
    console.log(props.hobby);
    console.log(props.sex);
    // 属性是只读的，不允许更改
    props.userName="lisi"; // 警告
}
</script>

<style scoped>
</style>
```

## useAttrs()

> 可以直接使用的在props中，通过传值过来的在attrs中

如果需要，你可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute：

```vue
<script setup>
import { useAttrs } from 'vue'

const attrs = useAttrs()
</script>
```

如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露：

```js
export default {
  setup(props, ctx) {
    // 透传 attribute 被暴露为 ctx.attrs
    console.log(ctx.attrs)
  }
}
```

需要注意的是，虽然这里的 `attrs` 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 `onUpdated()` 使得在每次更新时结合最新的 `attrs` 执行副作用。

## defineEmits()

为了在声明 props 和 emits 选项时获得完整的类型推导支持，我们可以使用 defineProps 和 defineEmits API，它们将自动地在 script setup 标签中可用

### 特点

```js
//  在vue3中没有了修饰符.native
//  父组件向子组件设置的事件，对于子组件而言都会作为属性来处理。
//  在JS中需要通过调用defineEmits 实现vue2中的this.$emit
//  模版中的$emits可以直接使用，vue3已经自动编译了
```



```js
<script setup>
const props = defineProps({
  foo: String
})

const emit = defineEmits(['change', 'delete'])
// setup 代码
</script>
```

- `defineProps` 和 `defineEmits` 都是只能在 `<script setup>` 中使用的**编译器宏**。他们不需要导入，且会随着 `<script setup>` 的处理过程一同被编译掉。
- `defineProps` 接收与 `props` 选项相同的值，`defineEmits` 接收与 `emits` 选项相同的值。
- `defineProps` 和 `defineEmits` 在选项传入后，会提供恰当的类型推导。
- 传入到 `defineProps` 和 `defineEmits` 的选项会从 setup 中提升到模块的作用域。因此，传入的选项不能引用在 setup 作用域中声明的局部变量。这样做会引起编译错误。但是，它可以引用导入的绑定，因为它们也在模块作用域内。

### 针对类型的 props/emit 声明

props 和 emit 也可以通过给 `defineProps` 和 `defineEmits` 传递纯类型参数的方式来声明（TS写法）：

```tsx
const props = defineProps<{
  foo: string
  bar?: number
}>()

const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()

// 3.3+：另一种更简洁的语法
const emit = defineEmits<{
  change: [id: number] // 具名元组语法
  update: [value: string]
}>()
```

### 使用类型声明时的默认 props 值

针对类型的 `defineProps` 声明的不足之处在于，它没有可以给 props 提供默认值的方式。为了解决这个问题，我们还提供了 `withDefaults` 编译器宏：

```tsx
export interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  msg: 'hello',
  labels: () => ['one', 'two']
})
```

上面代码会被编译为等价的运行时 props 的 `default` 选项。此外，`withDefaults` 辅助函数提供了对默认值的类型检查，并确保返回的 `props` 的类型删除了已声明默认值的属性的可选标志。

### 使用案例

**vue3通过自定义事件更改数据**

1. src->App.vue

```vue
<template>
    <h3>Vue3父向子通过属性进行参数的传递</h3>
    <h3>父组件App</h3>

    <button @click="count++">{{count}}</button>
    <button @click="setCount(2)">{{count}}</button>

	<!--添加自定义事件setCount-->
	<!--添加JS原生事件click-->
	<!--向子组件传值count-->
	<!--向子组件传递一个函数setCount-->
    <Child 
           @setCount="setCount" 
           @click="setCount" 
           :count="count" 
           :setCount="setCount"/>
</template>

<script lang="ts" setup>
// 注意：在vue3中没有了修饰符.native
//      父组件在子组件上设置的自定义事件，对于子组件而言都会作为子组件的$attrs中的属性来处理。
//      父@click---->子onClick
//      父@setCount---->子onSetCount
//      父组件设置"click"事件，子组件映射为$attrs中"onClick"属性
//      父组件设置"setCount"事件，子组件映射为$attrs中"onSetCount"属性
    
import Child from "@/components/Child.vue";
import {ref} from "vue";
const count = ref(100);
// 设置一个函数
const setCount = function(n:number){
    count.value += n;
}
</script>
```

2. src->components->Child.vue

```vue
<template>
	<!--方式1：子组件监听单击事件，执行子组件映射后的onSetCount函数-->
    <h3 @click="onSetCount(5)">子组件Child</h3>
	<!--方式2：子组件监听单击事件 执行父组件通过props传来的setCount函数-->
    <button @click="setCount(3)">{{count}}</button>
	<!--方式3：子组件监听单击事件 执行父组件自定义事件函数-->
	<!--模版中的$emits可以直接使用，vue3已经自动编译了-->
    <button @click="$emits('setCount',100)">{{count}}</button>
</template>

<script lang="ts" setup>
import {onMounted} from "vue";
// 获取props传递值
const props = defineProps(["count","setCount","onClick","onSetCount"]);
// 在JS中需要通过调用defineEmits 实现vue2中的this.$emit
const $emits = defineEmits(["setCount"]);
onMounted(()=>{
    // 调用父组件中的事件 click
    props.onClick(4);
    $emits("setCount",2)
})
</script>
```

### 状态提升

> 将数据状态放置在共有的父级中。父组件添加自定义事件，子组件通过defineEmits()获取（父元素自定义事件设置的属性值）函数，然后调用函数修改父元素数据。

1. src->App.vue

```vue
<template>
    <h3>App组件</h3>
    <button @click="num++">{{num}}</button>
    <hr/>
    <One @setNum="setNum" :num="num"/>
    <hr/>
    <Two  @setNum="setNum" :num="num"/>
</template>

<script lang="ts" setup>
import One from "@/components/One";
import Two from "@/components/Two";
import {ref} from "vue";
const num = ref(0);
const setNum = function(v:number=1){
    num.value += v;
}

</script>
```

2. src->components->One.vue

```vue
<template>
    <h3>One</h3>
    <button @click="changeNum">{{num}}</button>
</template>

<script setup lang="ts">
defineProps(["num"]);
const $emit = defineEmits(["setNum"]);
const changeNum = function(){
    $emit("setNum",2)
}
</script>
```

3. src->src->components->Two.vue

```vue
<template>
    <h3>Two</h3>
    <button @click="changeNum">{{num}}</button>
</template>

<script setup lang="ts">
defineProps(["num"])
const $emit = defineEmits(["setNum"]);
const changeNum = function(){
    $emit("setNum",3)
}
</script>
```

## 事件总线

### Vue.prototype

通过在Vue实例的原型连上增加一个属性 Vue.prototype.$bus  实现事件总线

### 事件总线的作用

```js
通过使用在Vue原型上设置一个属性(.$bus)，把父组件上设置的事件(this.$on("事件名"))和子组件上监听的事件(this.$emit("事件名"))串联起来(父组件和子组件的this不是同一个对象)。

通过使用 Vue.prototype.$bus = new Vue()

父组件和子组件在调用 this.$bus 指向的是同一个Vue实例，这就解决了this指向不同对象的问题

事件总线的使用：父组件上设置的事件(this.$bus.$on("事件名"))和子组件上监听的事件(this.$bus.$emit("事件名")),就可以实现父子之间传值。
```

```vue
<div id="app">
    <button @click="fn">FatherBtn</button>
	<hanser ></hanser>
</div>
```

```js
<script type="module">
    // 在Vue的原型上设置一个全局属性 .$bus
    Vue.prototype.$bus = new Vue();
    Vue.component("hanser",{
        data(){
            return{
                num:1
            }
        },
        template:(`
            <button @click="Hanser">hanserBtn</button>
        `),  
        methods:{
            Hanser(){
                // VueComponent的实例;$bus属性在 VueComponent.__proto__.prototype原型上
                console.log('子组件中的this',this); 
                // 子组件设置触发事件 Aqua，并传值
                this.$bus.$emit("Aqua","mooooooooo~");
            },
        },      
    })
    new Vue({
        el:'#app',
        data:{
            age:12
        },
        methods:{
            fn(){
                // 父组件设置触发事件 Aqua，并传值
                this.$bus.$emit('Aqua',"neeeeeeeee~");
            },
        },
        mounted(){
            // Vue的实例;$bus属性在 Vue.prototype上
            console.log("父组件中的this",this); 
            this.$bus.$on('Aqua',function(str){
                console.log('Aqua',str)
            })
        }
    })
    
</script>
```

### mitt插件

由于vue3中没有vue2中的Vue.prototype，所以在vue3中无事件总线。可以通过mitt插件实现类似效果

> 通过调用mitt函数的返回值(自定义为bus)
>
> bus是一个对象
>
> bus有方法emit，on，off，对应：触发，监听，取消事件。

1. 下载

```js
npm i mitt
```

2. 封装mitt：src->utils->index.ts

```tsx
import mitt from "mitt";
// 导出一个bus对象
export const bus = mitt();
```

3. src->components->One.vue

```vue
<template>
    <h3>{{num}}</h3>
</template>

<script setup lang="ts">

import {onMounted} from "vue";
import {bus} from "@/utils";

defineProps(["num"]);
onMounted(function(){
    // 监听一个事件 changenum
    bus.on("changenum",()=>{
        console.log("ONE->changenum");
        // bus.off("changenum");
    })
})
</script>
```

4. src->components->Two.vue

```vue
<template>
	<!--方式1-->
    <h3 @click="changeNum">{{num}}</h3>
	<!--方式2-->
    <h3 @click="bus.emit('changenum',300)">{{num}}</h3>
</template>

<script setup lang="ts">
import {bus} from "@/utils";

defineProps(["num"]);
// 定义一个函数，触发监听事件
const changeNum = function(){
    bus.emit("changenum",200);
}
</script>

<style scoped>

</style>
```

5. src->App.vue

```vue
<template>

    <h3>App组件（父组件）{{num}}</h3>

    <One :num="num"/>

    <Two :num="num"/>
</template>

<script lang="ts" setup>
import {onMounted, ref} from "vue";
import {bus} from "@/utils";
import One from "@/components/One.vue"
import Two from "@/components/Two.vue"
// 定义一个ref对象
const num = ref(100);
    
onMounted(function(){
    // 设置监听事件 changenum
    bus.on("changenum",(v)=>{
        console.log("APP->changenum",v);
        num.value = v as number;
    })
})
    
</script>

<style scoped>
</style>
```





2. src->components->Child.vue

```vue
<template>
    <h3 @click="$my('input','lisi')">我是一个子组件-Child:{{value}}</h3>
</template>

<script lang="ts" setup>
defineProps(["value"]);
const $my = defineEmits(["input"]);
</script>

<style scoped>

</style>
 
```

3. src->components->Child2.vue

```vue

```

## v-model

1. src->App.vue

```vue

```

2. src->components->Child.vue

```vue

```

## sync

> 注意：vue3废弃掉了.sync。vue2中的.sync相当于vue3中的v-model

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## $refs

## $children

## $parent

## provide()和inject()

> 可以被自己直接包裹或间接包裹的组件获取到数据。
>
> 通过provide传递，通过inject接收。接收之后数据可以修改，并支持响应式。

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## 作用域插槽

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

