# 组件通讯

## vue2父向子通过属性传递参数

1. src->App.vue

```vue
<template>
<div>
    <h3>vue2->父向子传递参数通过属性进行参数的传递</h3>
    <h3>父组件</h3>
    <p>userName:{{userName}}</p>
    <p>age:{{age}}</p>
    <hr/>
    <Child :userName="userName" :age="age" hobby="1"/>
    <hr/>
    <!--  上面使用子组件的语法糖，效果相同  -->
    <Child v-bind="{userName,age,hobby:'1'}" />
</div>
</template>

<script>
import Child from "@/components/Child";
export default {
    name: "App",
    components: {Child},
    data(){
        return {
            userName:"zhangsan",
            age:10
        }
    }
}
</script>

<style scoped>

</style>
```

2. src->components->Child.vue

```vue
<template>
    <div>
        <h3>子组件Child</h3>
        <p>props->userName->{{userName}}</p>
        <p>props->age->{{age}}</p>
        <p>props->hobby->{{hobby}}</p>
        <p>props->sex->{{sex}}</p>
        <button @click="fn">点我</button>
    </div>
</template>

<script>
export default {
    name: "Child",
    // 1- 数组，数组内的元素是字符串，字符串即是属性的名字
    // props:["userName","age"],
    // 2- 对象：对象的属性即是接收的属性。可以对类型进行限制
    // props:{
    //     // 字符串
    //     userName:String,
    //     // 数字
    //     age:Number
    // },
    // 3- 对象
    props:{
        userName:{
            type:String
        },
        age:{
            type:Number
        },
        hobby:{
            type:String,
            required:true
        },
        sex:{
            type:String,
            default:"男"
        }
    },
    methods:{
        fn(){
            // 可以通过this获取属性，且不允许修改
            console.log(this.userName,this.age,this.hobby,this.sex);
            this.userName= 1;
        }
    }
}
</script>

<style scoped>

</style>
```

## Vue3父向子通过属性进行参数的传递

1. src->App.vue  传递参数与vue2相同

```vue
<template>
    <h3>Vue3父向子通过属性进行参数的传递</h3>
    <h3>父组件App</h3>
    <p>userName:{{userName}}</p>
    <p>age:{{age}}</p>
    <hr/>
    <Child :userName="userName" :age="age" hobby="学习"/>
    <hr/>
    <Child v-bind="{userName,age,hobby:'学习'}"/>
</template>

<script lang="ts" setup>
import Child from "@/components/Child.vue";
import {ref} from "vue";
const userName = ref("vue3");
const age = ref(12);
</script>

<style scoped>
</style>
```

2. src->components->Child.vue 接收参数需要使用defineProps

```vue
<template>
    <h3>子组件Child</h3>
    <p>userName:{{ userName }}</p>
    <p>age:{{ age }}</p>
    <p>hobby:{{ hobby }}</p>
    <p>sex:{{ sex }}</p>
    <button @click="fn">点我</button>
</template>

<script lang="ts" setup>
// defineProps有两个特点：
// 1- 不需要引入，可以直接使用
// 2- 指定接收的属性，指定的属性可以在模板中直接使用。
//    在script标签中不能直接用。需要通过defineProps的返回值获取。



// 1- 数组，数组的元素是字符串
// defineProps(["userName", "age"]);
// 2- 对象
// defineProps({
//     userName:String,
//     age:Number
// })
// 3- 对象，对象的属性值还是对象
const props = defineProps({
    userName:{
        type:String
    },
    age:{
        type:Number
    },
    hobby:{
        type:String,
        required:true
    },
    sex:{
        type:String,
        default:"男"
    }
});
const fn = function(){
    console.log(props.userName);
    console.log(props.age);
    console.log(props.hobby);
    console.log(props.sex);
    // 属性是只读的，不允许更改
    // props.userName="lisi";
}
</script>

<style scoped>

</style>
 
```

## vue2自定义事件

1. src->App.vue

```vue

```

2. src->components->Child.vue

```vue

```

## vue3自定义事件

1. src->App.vue

```vue

```

2. src->components->Child.vue

```vue

```

## 状态提升

> 将状态放置在共有的父级中。

1. src->App.vue

```vue
<template>
    <h3>App组件</h3>
    <button @click="num++">{{num}}</button>
    <hr/>
    <One @setNum="setNum" :num="num"/>
    <hr/>
    <Two  @setNum="setNum" :num="num"/>
</template>

<script lang="ts" setup>
import One from "@/components/One";
import Two from "@/components/Two";
import {ref} from "vue";
const num = ref(0);
const setNum = function(v:number=1){
    num.value += v;
}

</script>

<style scoped>

</style>
```

2. src->components->One.vue

```vue

```

3. src->src->components->Two.vue

```vue

```

## vue3通过mitt完成事件总线

> vue3中没有vue2中的Vue.prototype,所以在vue3中无事件总线

1. 下载

```js

```

2. 挂载

```tsx

```

3. 使用：src->components->Two.vue

```vue

```

4. src->components->One.vue

```vue

```

5. src->components->App.vue

```vue

```

## Vue3-v-model实现父子数据同步

1. src->App.vue

```vue

```

2. src->components->Child.vue

```vue
<template>
    <h3 @click="$my('input','lisi')">我是一个子组件-Child:{{value}}</h3>
</template>

<script lang="ts" setup>
defineProps(["value"]);
const $my = defineEmits(["input"]);
</script>

<style scoped>

</style>
 
```

3. src->components->Child2.vue

```vue

```

## vue3使用多个v-model

1. src->App.vue

```vue

```

2. src->components->Child.vue

```vue

```

## sync

> 注意：vue3废弃掉了.sync。vue2中的.sync相当于vue3中的v-model

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## vue2之$attrs与$listeners

> 

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## vue3之useAttrs

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## vue2之$refs-$children-$parent

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## vue3之ref与$parent

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## 组合式API provide - inject

> 可以被自己直接包裹或间接包裹的组件获取到数据。
>
> 通过provide传递，通过inject接收。接收之后数据可以修改，并支持响应式。

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

## 作用域插槽

1. src->App.vue

```

```

2. src->component->Child.vue

```vue

```

